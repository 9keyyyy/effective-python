# 11 시퀀스를 슬라이싱하는 방법을 익혀라
## TL;DR

1. 슬라이싱 할때는 간결하게. 시작 인덱스에 0을 넣거나 끝 인덱스에 시퀀스 길이를 넣지 X
2. 슬라이싱은 범위를 넘어가는 시작 인덱스나 끝 인덱스도 허용
3. 리스트 슬라이스에 대입하면 원래 시퀀스에서 슬라이스가 가리키는 부분을 대입 연산자 오른쪽에 있는 시퀀스로 대치 (길이가 달라도 됨)

## 슬라이싱 구문 기본 형태

- 슬라이싱 구문의 기본 형태는 `리스트[시작:끝]`이다. 여기서 **시작 인덱스에 있는 원소는 슬라이스에 포함**되지만, **끝 인덱스에 있는 원소는 포함되지 않는다**.
  ```python
  a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
  print('가운데 2개:', a[3:5])
  print('마지막을 제외한 나머지:', a[1:7])
  
  >>>
  가운데 2개: ['d', 'e']
  마지막을 제외한 나머지: ['b', 'c', 'd', 'e', 'f', 'g']
  ```
- 리스트의 맨 앞부터 슬라이싱할 때는 시각적 잡음을 없애기 위해 0을 생략해야함
  ```python
  assert a[:5] == a[0:5]
  ```
- 리스트의 끝까지 슬라이싱할 때는 쓸데없이 끝 인덱스를 적지 마라.
  ```python
  assert a[5:] == a[5:len(a)]
  ```

## 슬라이싱 역 인덱싱

- 리스트의 **끝에서부터 원소를 찾고 싶으면 음수 인덱스 사용**
- 아래의 형태처럼 사용 가능
  ```
  a[:]
  a[:5]
  a[:-1]
  a[4:]
  a[-3:]
  a[2:5]
  a[2:-1]
  a[-3:-1]
  ```
- 슬라이싱할 때 **리스트의 인덱스 범위를 넘어가는 시작과 끝 인덱스는 무시**됨
- 이런 동작 방식으로 인해 코드에서 입력 시퀀스를 다룰 때 원하는 최대 길이 쉽게 지정 가능
  ```python
  first_twenty_items = a[:20]
  last_twenty_items = a[-20:]
  ```
- 반면 같은 인덱스에 **직접 접근**하면 예외 발생함
  ```python
  a[20] # list index out of range
  ```
- 슬라이싱할 때 음수 인덱스를 사용하면 놀랄 만한 결과가 생길 수 있음
    - 예를 들어 `somelist[-n:]`은 **n이 0보다 큰 경우 잘 작동**하지만 (예: `somelist[-3:]`)
    - n이 0이면 somelist[-0:]이라는 식이 somelist[:]과 같기 때문에 **원래의 리스트를 복사한 리스트가 얻어짐**

## 슬라이싱 결과 및 참조 값

- 리스트를 슬라이싱한 결과는 완전히 새로운 리스트이며, 원래 리스트에 대한 참조는 그대로 유지됨
- 슬라이싱한 결과로 얻은 리스트를 변경해도 원래 리스트는 바뀌지 않음
  ```python
  b = a[3:]
  print('이전',: b)
  b[1] = 99
  print('이후:', b)
  print('변화 없음:', a)
  
  >>>
  이전: ['d','e','f','g','h']
  이후: ['d','99','f','g','h']
  변화 없음: ['a','b','c','d','e','f','g','h']
  ```
- 대입에 슬라이스를 사용하면 원본 리스트에서 지정한 범위에 들어 있는 원소를 변경함
  - 언패킹 대입(예를 들면, a, b = c[:2])과 달리 슬라이스 대입에서는 슬라이스와 대입되는 리스트의 길이가 같은 필요가 없음
  - 대입된 슬라이스 이전이나 이후에 있던 원소들은 그대로 유지됨
  ```python
  print('이전:', a)
  a[2:7] = [99, 22, 14]
  print('이후:', a)
  >>>
  이전: ['a','b','c','d','e','f','g','h']
  이후: ['a','b',99,22,14,'h']
  ```
- 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 길 때는 리스트가 증가함
  ```python
  print('이전:', a)
  a[2:3] = [47, 11]
  print('이후:', a)
  >>>
  이전: ['a','b',99,22,14,'h']
  이후: ['a','b',47,11,22,14,'h']
  ```
- 슬라이싱에서 시작과 끝 인덱스를 모두 생략하면 원래 리스트를 복사한 **새 리스트**를 얻게 됨
  ```python
  b = a[:]
  assert b == a and b is not a
  ```
- 시작과 끝 인덱스가 없는 슬라이스에 대입하면 (새 리스트를 만들어내는 대신) 슬라이스가 참조하는 리스트의 내용을 대입하는(연산자 오른쪽에 있는) 리스트의 복사본으로 덮어 씀
  ```python
  b = a
  
  print('이전 a:', a)
  print('이전 b:', b)
  a[:] = [101, 102, 103]
  assert a is b # 여전히 같은 리스트 객체임
  print('이후 a:', a) # 새로운 내용이 들어있음
  print('이후 b:', b) # 같은 리스트 객체이기 때문에 a와 내용이 같음
  >>>
  이전 a: ['a','b',47,11,22,14,'h']
  이전 b: ['a','b',47,11,22,14,'h']
  이후 a: [101,102,103]
  이후 b: [101,102,103]
  ```
