# 32 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라

### TL;DR

- 입력이 너무 크면 메모리를 많이 사용하기 때문에 리스트 컴프리헨션은 문제를 일으킬 수 있다.
- **제너레이터 식**은 이터레이터처럼 한번에 원소를 하나씩만 출력하므로 메모리 문제를 피할 수 있다.
- 제너레이터 식이 반환한 이터레이터를 다른 제너레이터 식의 하위 식으로 사용하여 제너레이터 식을 서로 합성할 수 있다.
- 연결된 제너레이터 식은 매우 빠르게 실행되어 메모리도 효율적으로 사용할 수 있다.

**예시**

```python
value = [len(x) for x in open('my_file.txt')]
print(value)

>>>
[100, 57, 15, 1, 12]

```

파일의 크기가 크다면, 리스트 컴프리헨션을 사용하는 것이 문제가 될 수 있음

### 제너레이터 식 (Generater expression)

- 리스트 컴프리헨션과 제너레이터를 일반화한 것
- 제너레이터 식을 실행해도 출력 시퀀스 전체가 실체화되지 않음
- 제너레이터 식에 들어있는 식으로부터 원소를 하나씩 만들어내는 이터레이터가 생성

```python
it = (len(x) for x in open('my_file.txt'))
print(it)

>>>
<generator object <genexpr> at 0x108993dd0>

```

### 제너레이터 식 값 반환

next 내장 함수를 사용하여 다음 값을 얻어올 수 있음

```python
print(next(it))
print(next(it))

>>>
100
57

```

### 두 제너레이터의 합성
```python
roots = ((x, x**0.5) for x in it)

print(next(roots))

>>>
(15, 3.872983346)

```
- 앞에서 본 제너레이 식이 반환한 이터레이터를 다른 제너레이터 식의 입력으로 사용
- 이 모든 과정이 가능한 메모리를 효율적으로 사용하며 이루어짐

