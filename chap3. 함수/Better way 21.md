# 21 변수 영역과 클로저의 상호작용 방식을 이해하라

## TL;DR

- `클로저` 함수는 자신이 정의된 영역 외부에서 정의된 변수도 참조
- 기본적으로 클로저 내부에 사용한 대입문은 클로저를 감싸는 영역에 영향을 끼칠 수 없음
- 클로저가 자신을 감싸는 영역의 변수를 변경한다는 사실을 표시할 때는 `nonlocal` 문을 사용
- 간단한 함수가 아닌 경우에는 `nonlocal` 문을 **사용하지 말 것**

## List 정렬

- 숫자로 이뤄진 list를 정렬하되, 정렬한 리스트의 앞쪽에는 우선순위를 부여한 몇몇 숫자를 위치시켜야 한다고 가정
- 일반적인 방법은 리스트의 `sort` 메서드에 `key` 인자로 도우미 함수를 전달하는 것 (Better way 14: '복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 참고)
- list는 각 원소를 정렬할 때 이 도우미 함수가 반환하는 값을 기준으로 사용함
- 도우미 함수는 주어진 원소가 중요한 숫자 그룹에 들어 있는지 검사해서 정렬 기준값을 적절히 조정해줌
  ```python
  def sort_priority(values, group):
      def helper(x):
          if x in group:
              return (0, x)
          return (1, x)
      values.sort(key=helper)
  ```
- 이 함수는 입력이 간단하면 잘 작동함
  ```python
  numbers = [8, 3, 1, 2, 5, 4, 7, 6]
  group = {2, 3, 5, 7}
  sort_priority(numbers, group)
  print(numbers)
  
  >>>
  [2, 3, 5, 7, 1, 4, 6, 8]
  ```
### 작동하는 이유 세가지
1. **파이썬이 `클로저(closer)`를 지원**
    - 클로저란 자신이 정의된 영역 밖의 변수를 참조하는 함수이며, 클로저로 인해 도우미 함수가 `sort_priority`함수의 group 인자에 접근할 수 있음
2. **파이썬에서 함수가 `일급 시민(first-class citizen)` 객체임**
    - 일급 시민 객체라는 말은 이를 직접 가리킬 수 있고, 변수에 대입하거나 다른 함수에 인자로 전달할 수 있으며, 식이나 if 문에서 함수를 비교하거나 함수에서 반환하는 것 등이 가능하다는 것을 의미하며, 이 성질로 인해 `sort` 메서드는 클로저 함수를 `key` 인자로 받을 수 있음
3. **파이썬에서는 `시퀀스(튜플 포함)`를 비교하는 구체적인 규칙이 있음**
    - 파이썬은 시퀀스를 비교할 때 0번 인덱스에 있는 값을 비교한 다음, 이 값이 같으면 다시 1번 인덱스에 있는 값을 비교함
    - 이런 식으로 순서대로 원소를 비교해 두 값이 같으면 그다음 원소로 넘어가는 작업을 시퀀스의 모든 원소를 다 비교하거나 결과가 정해질 때까지 계속함
    - 이로 인해 `helper` 클로저가 반환하는 튜플이 서로 다른 두 그룹을 정렬하는 기준 역할을 할 수 있음

### 우선순위가 높은 원소가 있을 때와 아닌 때를 구분하기
- 이미 각 원소가 어떤 그룹에 들어 있는지 결정하는 클로저 함수가 있으므로, 여기에 우선순위가 높은 원소를 발견했음을 표시하는 플래그를 설정
- 이렇게 클로저 함수를 바꾸고 나면 정렬 함수가 플래그 값을 반환함

#### 잘못된 구현
```python
def sort_priority2(numbers, group):
    found = False
    def helper(x):
        if x in group:
            found = True 
            return (0, x)
        return (1, x)
    numbers.sort(key=helper)
    return found
```

```python
found = sort_priority2(numbers, group)
print('발견:', found)
print(numbers)

>>>
발견: False
[2, 3, 5, 7, 1, 4, 6, 8]

```

- 정렬 결과는 맞음: `group`이 `numbers` 안에 있는 수를 찾음
- 하지만 함수가 반환하는 `found`는 `True`여야 하는데 `False`임
- 식 안에서 변수를 **참조**할 때 파이썬 인터프리터는 이 참조를 해결하기 위해 다음 순서로 영역을 뒤짐
    1. 현재 함수의 영역
    2. 현재 함수를 둘러싼 영역(현재 함수를 둘러싸고 있는 함수 등)
    3. 현재 코드가 들어있는 모듈의 영역(**전역 영역(`global scope`)**이라고도 부름)
    4. 내장 영역(`built-in scope`)(`len`, `str` 등의 함수가 들어 있는 영역)
- 식이 참조하는 이름에 해당하는 변수가 이 네 가지 영역에 없으면 NameError 예외가 발생함
  ```python
  foo = does_not_exist * 5
  
  >>>
  Traceback ...
  NameError: name 'does_not_exist' is not defined
  ```
- 변수에 값을 **대입**하는 것은 다른 방식으로 작동함
    - 변수가 현재 영역에 이미 정의돼 있다면 그 변수의 값만 새로운 값으로 바뀜
    - 하지만 변수가 현재 영역에 정의돼 있지 않다면 파이썬은 변수 대입을 변수 정의로 취급함
    - 결정적으로 이렇게 새로 정의된 변수의 영역은 해당 대입문이나 식이 들어 있던 함수가 됨
- 이런 대입의 동작 방식을 알면 sort_priority2의 반환 값이 달라진 이유를 알 수 있음
    - `found` 변수는 `helper` 도우미 함수의 영역에서 `True`로 대입됨
    - 따라서 helper 함수의 클로저 안에서 이 대입문은 `helper` 영역 안에 새로운 변수를 정의하는 것으로 취급됨
    - 즉, `sort_priority2` 안에서 기존 변수에 값을 대입하는 것으로 취급되는 것이 아님


## 영역 지정 버그 (`scoping bug`)

이 문제는 초보 바이썬 프로그래머를 종종 당황하게 만들기 때문에 **영역 지정 버그(`scoping bug`)**라고 부르기도 함
- 해당 동작은 의도에 따른 결과임
- 함수에서 사용한 지역 변수가 그 함수를 포함하고 있는 **모듈 영역을 더럽히지 못하게 막는 것임**
- 이런 식으로 처리하지 않으면 함수 내에서 사용한 모든 대입문이 전역 모듈 영역에 쓰레기 변수를 추가하게 됨
- 그 결과, 추가된 불필요한 변수들로 인해 잡음이 늘어날 뿐 아니라 추가된 전역 변수와 클로저의 상호작용에 의해 알아내기 힘든 미묘한 버그가 생길 수 있음

## nonlocal 문

- 파이썬에는 클로저 밖으로 데이터를 끌어내는 특별한 구문이 있음
    - `nonlocal` 문이 지정된 변수에 대해서는 앞에서 설명한 영역 결정 규칙에 따라 대입될 변수의 영역이 결정됨
    - `nonlocal`의 유일한 한계점은 (전역 영역을 더럽히지 못하도록) 모듈 수준 영역까지 변수 이름을 찾아 올라가지 않는 것임
- `nonlocal` 문은 **대입할 데이터가 클로저 밖에 있어서 다른 영역에 속한다는 사실을 분명히 알려줌**
    - 이 문장은 변수 대입 시 직접 모듈 영역(전역 영역)을 사용해야 한다고 지정하는 `global` 문을 보완해줌
- **간단한 함수 외에는 어떤 경우라도 `nonlocal`을 사용하지 말 것**
    - 특히 함수가 길고 `nonlocal` 문이 지정한 변수와 대입이 이뤄지는 위치의 거리가 멀면 함수 동작을 이해하기 더 힘들어짐

## 대안

클래스를 사용하여 해결 (Better way 38: '간단한 인터페이스의 경우 클래스 대신 함수를 받아라')
```python
class Sorter:
    def __init__(self, group):
        self.group = group
        self.found = False

    def __call__(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)

sorter = Sorter(group)
numbers.sort(key=sorter)
assert sorter.found is True
```
